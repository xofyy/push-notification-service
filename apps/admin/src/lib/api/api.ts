/* tslint:disable */
/* eslint-disable */
/**
 * Push Notification Service API
 *        Enterprise-grade Push Notification Service supporting iOS, Android, and Web platforms.              ## Features       - üöÄ Multi-platform push notifications (FCM, APNs, Web Push)       - üì± Advanced device management and segmentation       - üìä Real-time analytics and delivery tracking       - üè∑Ô∏è Template-based notifications with variable substitution       - ‚ö° High-performance queue system with BullMQ       - üîí Enterprise security with API key authentication       - üõ°Ô∏è Rate limiting for API protection       - üìà 99.9% uptime reliability target              ## Authentication       All endpoints require an API key in the `X-API-Key` header.              ## Rate Limiting       API endpoints are rate-limited to ensure fair usage:       - **High Frequency**: 100 requests/minute (notifications, events)       - **Medium Frequency**: 300 requests/minute (device management)       - **Low Frequency**: 1000 requests/hour (analytics, admin)              Rate limit headers are included in all responses:       - `X-RateLimit-Limit`: Maximum requests allowed       - `X-RateLimit-Remaining`: Requests remaining in current window       - `X-RateLimit-Reset`: Unix timestamp when the rate limit resets     
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@yourcompany.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface CreateTemplateDto {
    /**
     * Template name
     */
    'name': string;
    /**
     * Template description
     */
    'description'?: string;
    /**
     * Notification title template
     */
    'title': string;
    /**
     * Notification body template
     */
    'body': string;
    /**
     * Image URL template
     */
    'imageUrl'?: string;
    /**
     * Custom data template
     */
    'data'?: object;
    /**
     * Template variables
     */
    'variables'?: Array<string>;
    /**
     * Template status
     */
    'status'?: CreateTemplateDtoStatusEnum;
    /**
     * Default variable values
     */
    'defaultValues'?: object;
    /**
     * Template language
     */
    'language'?: string;
    /**
     * Validation rules for variables
     */
    'validationRules'?: object;
    /**
     * Template version
     */
    'version'?: number;
    /**
     * Created by user ID
     */
    'createdBy'?: string;
}

export const CreateTemplateDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type CreateTemplateDtoStatusEnum = typeof CreateTemplateDtoStatusEnum[keyof typeof CreateTemplateDtoStatusEnum];

export interface ErrorResponseDto {
    'statusCode': number;
    'error': string;
    'message': object;
    'timestamp': string;
    'path': string;
    'code'?: string;
}
export interface NotificationsList200Response {
    'items'?: Array<object>;
    'total'?: number;
    'limit'?: number;
    'offset'?: number;
}
export interface RenderTemplateDto {
    /**
     * Template ID or name to render
     */
    'template': string;
    /**
     * Variables to substitute in template
     */
    'variables': object;
    /**
     * Preview mode - do not save statistics
     */
    'preview'?: boolean;
}
export interface UpdateTemplateDto {
    /**
     * Template name
     */
    'name'?: string;
    /**
     * Template description
     */
    'description'?: string;
    /**
     * Notification title template
     */
    'title'?: string;
    /**
     * Notification body template
     */
    'body'?: string;
    /**
     * Image URL template
     */
    'imageUrl'?: string;
    /**
     * Custom data template
     */
    'data'?: object;
    /**
     * Template variables
     */
    'variables'?: Array<string>;
    /**
     * Template status
     */
    'status'?: UpdateTemplateDtoStatusEnum;
    /**
     * Default variable values
     */
    'defaultValues'?: object;
    /**
     * Template language
     */
    'language'?: string;
    /**
     * Validation rules for variables
     */
    'validationRules'?: object;
    /**
     * Template version
     */
    'version'?: number;
    /**
     * Created by user ID
     */
    'createdBy'?: string;
    /**
     * Updated by user ID
     */
    'updatedBy'?: string;
}

export const UpdateTemplateDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type UpdateTemplateDtoStatusEnum = typeof UpdateTemplateDtoStatusEnum[keyof typeof UpdateTemplateDtoStatusEnum];

export interface ValidateTemplateDto {
    /**
     * Template title to validate
     */
    'title': string;
    /**
     * Template body to validate
     */
    'body': string;
    /**
     * Template image URL to validate
     */
    'imageUrl'?: string;
    /**
     * Template data to validate
     */
    'data'?: object;
    /**
     * Test variables for validation
     */
    'testVariables': object;
}

/**
 * AnalyticsApi - axios parameter creator
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export analytics data
         * @param {string} projectId Project ID
         * @param {AnalyticsExportFormatEnum} [format] Export format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsExport: async (projectId: string, format?: AnalyticsExportFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsExport', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/export`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user engagement metrics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetEngagementMetrics: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsGetEngagementMetrics', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/engagement`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get analytics events with filtering and pagination
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetEvents: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsGetEvents', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/events`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get notification analytics and performance metrics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetNotificationAnalytics: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsGetNotificationAnalytics', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/notifications`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get notification conversion funnel
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetNotificationFunnel: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsGetNotificationFunnel', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/notifications/funnel`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get system performance metrics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetPerformanceMetrics: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsGetPerformanceMetrics', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/performance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get real-time analytics dashboard data
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetRealTimeData: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsGetRealTimeData', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/realtime`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project analytics overview
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsOverview: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsOverview', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/overview`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Server-Sent Events for real-time analytics (last hour, updates every 30s)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsRealtimeSSE: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsRealtimeSSE', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/realtime-sse`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Track multiple analytics events in batch
         * @param {string} projectId Project ID
         * @param {any} body Batch payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsTrackBatch: async (projectId: string, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsTrackBatch', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('analyticsTrackBatch', 'body', body)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/events/batch`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Track a single analytics event
         * @param {string} projectId Project ID
         * @param {any} body Event payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsTrackEvent: async (projectId: string, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('analyticsTrackEvent', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('analyticsTrackEvent', 'body', body)
            const localVarPath = `/api/v1/projects/{projectId}/analytics/events`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 */
export const AnalyticsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Export analytics data
         * @param {string} projectId Project ID
         * @param {AnalyticsExportFormatEnum} [format] Export format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsExport(projectId: string, format?: AnalyticsExportFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsExport(projectId, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user engagement metrics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsGetEngagementMetrics(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsGetEngagementMetrics(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsGetEngagementMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get analytics events with filtering and pagination
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsGetEvents(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsGetEvents(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsGetEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get notification analytics and performance metrics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsGetNotificationAnalytics(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsGetNotificationAnalytics(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsGetNotificationAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get notification conversion funnel
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsGetNotificationFunnel(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsGetNotificationFunnel(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsGetNotificationFunnel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get system performance metrics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsGetPerformanceMetrics(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsGetPerformanceMetrics(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsGetPerformanceMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get real-time analytics dashboard data
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsGetRealTimeData(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsGetRealTimeData(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsGetRealTimeData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project analytics overview
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsOverview(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsOverview(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Server-Sent Events for real-time analytics (last hour, updates every 30s)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsRealtimeSSE(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsRealtimeSSE(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsRealtimeSSE']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Track multiple analytics events in batch
         * @param {string} projectId Project ID
         * @param {any} body Batch payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsTrackBatch(projectId: string, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsTrackBatch(projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsTrackBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Track a single analytics event
         * @param {string} projectId Project ID
         * @param {any} body Event payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsTrackEvent(projectId: string, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsTrackEvent(projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsTrackEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Export analytics data
         * @param {string} projectId Project ID
         * @param {AnalyticsExportFormatEnum} [format] Export format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsExport(projectId: string, format?: AnalyticsExportFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsExport(projectId, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user engagement metrics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetEngagementMetrics(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsGetEngagementMetrics(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get analytics events with filtering and pagination
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetEvents(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsGetEvents(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get notification analytics and performance metrics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetNotificationAnalytics(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsGetNotificationAnalytics(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get notification conversion funnel
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetNotificationFunnel(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsGetNotificationFunnel(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get system performance metrics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetPerformanceMetrics(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsGetPerformanceMetrics(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get real-time analytics dashboard data
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetRealTimeData(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsGetRealTimeData(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project analytics overview
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsOverview(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsOverview(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Server-Sent Events for real-time analytics (last hour, updates every 30s)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsRealtimeSSE(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsRealtimeSSE(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Track multiple analytics events in batch
         * @param {string} projectId Project ID
         * @param {any} body Batch payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsTrackBatch(projectId: string, body: any, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsTrackBatch(projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Track a single analytics event
         * @param {string} projectId Project ID
         * @param {any} body Event payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsTrackEvent(projectId: string, body: any, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsTrackEvent(projectId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * @summary Export analytics data
     * @param {string} projectId Project ID
     * @param {AnalyticsExportFormatEnum} [format] Export format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsExport(projectId: string, format?: AnalyticsExportFormatEnum, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsExport(projectId, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user engagement metrics
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsGetEngagementMetrics(projectId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsGetEngagementMetrics(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get analytics events with filtering and pagination
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsGetEvents(projectId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsGetEvents(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get notification analytics and performance metrics
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsGetNotificationAnalytics(projectId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsGetNotificationAnalytics(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get notification conversion funnel
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsGetNotificationFunnel(projectId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsGetNotificationFunnel(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get system performance metrics
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsGetPerformanceMetrics(projectId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsGetPerformanceMetrics(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get real-time analytics dashboard data
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsGetRealTimeData(projectId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsGetRealTimeData(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project analytics overview
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsOverview(projectId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsOverview(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Server-Sent Events for real-time analytics (last hour, updates every 30s)
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsRealtimeSSE(projectId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsRealtimeSSE(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Track multiple analytics events in batch
     * @param {string} projectId Project ID
     * @param {any} body Batch payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsTrackBatch(projectId: string, body: any, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsTrackBatch(projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Track a single analytics event
     * @param {string} projectId Project ID
     * @param {any} body Event payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public analyticsTrackEvent(projectId: string, body: any, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsTrackEvent(projectId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

export const AnalyticsExportFormatEnum = {
    Json: 'json',
    Csv: 'csv'
} as const;
export type AnalyticsExportFormatEnum = typeof AnalyticsExportFormatEnum[keyof typeof AnalyticsExportFormatEnum];


/**
 * AppApi - axios parameter creator
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/hello`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppApi - functional programming interface
 */
export const AppApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppApi.appGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appGetInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appGetInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppApi.appGetInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppApi - factory interface
 */
export const AppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetHello(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appGetHello(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetInfo(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appGetInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppApi - object-oriented interface
 */
export class AppApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appGetHello(options?: RawAxiosRequestConfig) {
        return AppApiFp(this.configuration).appGetHello(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appGetInfo(options?: RawAxiosRequestConfig) {
        return AppApiFp(this.configuration).appGetInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DevicesApi - axios parameter creator
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesAddTags: async (xAPIKey: string, projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesAddTags', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesAddTags', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesAddTags', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}/tags`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {string} topic 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesAddToTopic: async (xAPIKey: string, projectId: string, id: string, topic: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesAddToTopic', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesAddToTopic', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesAddToTopic', 'id', id)
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('devicesAddToTopic', 'topic', topic)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}/topics/{topic}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} dryRun 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCleanupTokens: async (xAPIKey: string, projectId: string, dryRun: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesCleanupTokens', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesCleanupTokens', 'projectId', projectId)
            // verify required parameter 'dryRun' is not null or undefined
            assertParamExists('devicesCleanupTokens', 'dryRun', dryRun)
            const localVarPath = `/api/v1/projects/{projectId}/devices/cleanup-tokens`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dryRun'] = dryRun;
            }



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCountDevicesBySegment: async (xAPIKey: string, projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesCountDevicesBySegment', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesCountDevicesBySegment', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('devicesCountDevicesBySegment', 'body', body)
            const localVarPath = `/api/v1/projects/{projectId}/devices/segment/count`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} platform 
         * @param {string} userId 
         * @param {string} tags 
         * @param {string} topics 
         * @param {string} isActive 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesFindAll: async (xAPIKey: string, projectId: string, platform: string, userId: string, tags: string, topics: string, isActive: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesFindAll', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesFindAll', 'projectId', projectId)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('devicesFindAll', 'platform', platform)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('devicesFindAll', 'userId', userId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('devicesFindAll', 'tags', tags)
            // verify required parameter 'topics' is not null or undefined
            assertParamExists('devicesFindAll', 'topics', topics)
            // verify required parameter 'isActive' is not null or undefined
            assertParamExists('devicesFindAll', 'isActive', isActive)
            const localVarPath = `/api/v1/projects/{projectId}/devices`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (topics !== undefined) {
                localVarQueryParameter['topics'] = topics;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesFindOne: async (xAPIKey: string, projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesFindOne', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesFindOne', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesFindOne', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetProjectTags: async (xAPIKey: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesGetProjectTags', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesGetProjectTags', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/devices/tags`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetPropertyStats: async (xAPIKey: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesGetPropertyStats', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesGetPropertyStats', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/devices/properties/stats`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetStats: async (xAPIKey: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesGetStats', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesGetStats', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/devices/stats`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetTagStats: async (xAPIKey: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesGetTagStats', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesGetTagStats', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/devices/tags/stats`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetTokensBySegment: async (xAPIKey: string, projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesGetTokensBySegment', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesGetTokensBySegment', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('devicesGetTokensBySegment', 'body', body)
            const localVarPath = `/api/v1/projects/{projectId}/devices/segment/tokens`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesQueryDevicesBySegment: async (xAPIKey: string, projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesQueryDevicesBySegment', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesQueryDevicesBySegment', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('devicesQueryDevicesBySegment', 'body', body)
            const localVarPath = `/api/v1/projects/{projectId}/devices/segment/query`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRefreshToken: async (xAPIKey: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesRefreshToken', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesRefreshToken', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/devices/refresh-token`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Registers a new device for push notifications with enhanced validation.       Automatically detects platform and validates device tokens.       Rate limited to 100 requests per minute.     
         * @summary Register device
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {any} body Device registration payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRegister: async (xAPIKey: string, projectId: string, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesRegister', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesRegister', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('devicesRegister', 'body', body)
            const localVarPath = `/api/v1/projects/{projectId}/devices/register`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRegisterBasic: async (xAPIKey: string, projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesRegisterBasic', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesRegisterBasic', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('devicesRegisterBasic', 'body', body)
            const localVarPath = `/api/v1/projects/{projectId}/devices/register/basic`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRemove: async (xAPIKey: string, projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesRemove', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesRemove', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesRemove', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {string} topic 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRemoveFromTopic: async (xAPIKey: string, projectId: string, id: string, topic: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesRemoveFromTopic', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesRemoveFromTopic', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesRemoveFromTopic', 'id', id)
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('devicesRemoveFromTopic', 'topic', topic)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}/topics/{topic}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRemoveProperties: async (xAPIKey: string, projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesRemoveProperties', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesRemoveProperties', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesRemoveProperties', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}/properties`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRemoveTags: async (xAPIKey: string, projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesRemoveTags', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesRemoveTags', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesRemoveTags', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}/tags`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSetProperties: async (xAPIKey: string, projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesSetProperties', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesSetProperties', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesSetProperties', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}/properties`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesTestSegmentQuery: async (xAPIKey: string, projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesTestSegmentQuery', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesTestSegmentQuery', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('devicesTestSegmentQuery', 'body', body)
            const localVarPath = `/api/v1/projects/{projectId}/devices/segment/test`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdate: async (xAPIKey: string, projectId: string, id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesUpdate', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesUpdate', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('devicesUpdate', 'body', body)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdateProperties: async (xAPIKey: string, projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesUpdateProperties', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesUpdateProperties', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesUpdateProperties', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}/properties`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdateToken: async (xAPIKey: string, projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesUpdateToken', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesUpdateToken', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesUpdateToken', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/devices/{id}/token`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Validates a device token for a specific platform.       Checks token format and verifies with the respective push service.       Rate limited to 10 requests per minute due to external API calls.     
         * @summary Validate device token
         * @param {string} xAPIKey API Key for authentication
         * @param {any} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesValidateToken: async (xAPIKey: string, projectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesValidateToken', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesValidateToken', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/devices/validate-token`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {any} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesValidateTokensBatch: async (xAPIKey: string, projectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('devicesValidateTokensBatch', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('devicesValidateTokensBatch', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/devices/validate-tokens-batch`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 */
export const DevicesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesAddTags(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesAddTags(xAPIKey, projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesAddTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {string} topic 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesAddToTopic(xAPIKey: string, projectId: string, id: string, topic: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesAddToTopic(xAPIKey, projectId, id, topic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesAddToTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} dryRun 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCleanupTokens(xAPIKey: string, projectId: string, dryRun: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesCleanupTokens(xAPIKey, projectId, dryRun, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesCleanupTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCountDevicesBySegment(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesCountDevicesBySegment(xAPIKey, projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesCountDevicesBySegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} platform 
         * @param {string} userId 
         * @param {string} tags 
         * @param {string} topics 
         * @param {string} isActive 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesFindAll(xAPIKey: string, projectId: string, platform: string, userId: string, tags: string, topics: string, isActive: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesFindAll(xAPIKey, projectId, platform, userId, tags, topics, isActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesFindOne(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesFindOne(xAPIKey, projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetProjectTags(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesGetProjectTags(xAPIKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesGetProjectTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetPropertyStats(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesGetPropertyStats(xAPIKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesGetPropertyStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetStats(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesGetStats(xAPIKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesGetStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetTagStats(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesGetTagStats(xAPIKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesGetTagStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetTokensBySegment(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesGetTokensBySegment(xAPIKey, projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesGetTokensBySegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesQueryDevicesBySegment(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesQueryDevicesBySegment(xAPIKey, projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesQueryDevicesBySegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRefreshToken(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesRefreshToken(xAPIKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *        Registers a new device for push notifications with enhanced validation.       Automatically detects platform and validates device tokens.       Rate limited to 100 requests per minute.     
         * @summary Register device
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {any} body Device registration payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRegister(xAPIKey: string, projectId: string, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesRegister(xAPIKey, projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRegisterBasic(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesRegisterBasic(xAPIKey, projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesRegisterBasic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRemove(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesRemove(xAPIKey, projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {string} topic 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRemoveFromTopic(xAPIKey: string, projectId: string, id: string, topic: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesRemoveFromTopic(xAPIKey, projectId, id, topic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesRemoveFromTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRemoveProperties(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesRemoveProperties(xAPIKey, projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesRemoveProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRemoveTags(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesRemoveTags(xAPIKey, projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesRemoveTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetProperties(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesSetProperties(xAPIKey, projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesSetProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesTestSegmentQuery(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesTestSegmentQuery(xAPIKey, projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesTestSegmentQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdate(xAPIKey: string, projectId: string, id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesUpdate(xAPIKey, projectId, id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdateProperties(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesUpdateProperties(xAPIKey, projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesUpdateProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdateToken(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesUpdateToken(xAPIKey, projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesUpdateToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *        Validates a device token for a specific platform.       Checks token format and verifies with the respective push service.       Rate limited to 10 requests per minute due to external API calls.     
         * @summary Validate device token
         * @param {string} xAPIKey API Key for authentication
         * @param {any} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesValidateToken(xAPIKey: string, projectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesValidateToken(xAPIKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesValidateToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {any} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesValidateTokensBatch(xAPIKey: string, projectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesValidateTokensBatch(xAPIKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesValidateTokensBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DevicesApi - factory interface
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesAddTags(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesAddTags(xAPIKey, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {string} topic 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesAddToTopic(xAPIKey: string, projectId: string, id: string, topic: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesAddToTopic(xAPIKey, projectId, id, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} dryRun 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCleanupTokens(xAPIKey: string, projectId: string, dryRun: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesCleanupTokens(xAPIKey, projectId, dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCountDevicesBySegment(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesCountDevicesBySegment(xAPIKey, projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} platform 
         * @param {string} userId 
         * @param {string} tags 
         * @param {string} topics 
         * @param {string} isActive 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesFindAll(xAPIKey: string, projectId: string, platform: string, userId: string, tags: string, topics: string, isActive: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesFindAll(xAPIKey, projectId, platform, userId, tags, topics, isActive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesFindOne(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesFindOne(xAPIKey, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetProjectTags(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesGetProjectTags(xAPIKey, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetPropertyStats(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesGetPropertyStats(xAPIKey, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetStats(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesGetStats(xAPIKey, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetTagStats(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesGetTagStats(xAPIKey, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetTokensBySegment(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesGetTokensBySegment(xAPIKey, projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesQueryDevicesBySegment(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesQueryDevicesBySegment(xAPIKey, projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRefreshToken(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesRefreshToken(xAPIKey, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         *        Registers a new device for push notifications with enhanced validation.       Automatically detects platform and validates device tokens.       Rate limited to 100 requests per minute.     
         * @summary Register device
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {any} body Device registration payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRegister(xAPIKey: string, projectId: string, body: any, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.devicesRegister(xAPIKey, projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRegisterBasic(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesRegisterBasic(xAPIKey, projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRemove(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesRemove(xAPIKey, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {string} topic 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRemoveFromTopic(xAPIKey: string, projectId: string, id: string, topic: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesRemoveFromTopic(xAPIKey, projectId, id, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRemoveProperties(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesRemoveProperties(xAPIKey, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRemoveTags(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesRemoveTags(xAPIKey, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSetProperties(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesSetProperties(xAPIKey, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesTestSegmentQuery(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesTestSegmentQuery(xAPIKey, projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdate(xAPIKey: string, projectId: string, id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesUpdate(xAPIKey, projectId, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdateProperties(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesUpdateProperties(xAPIKey, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdateToken(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesUpdateToken(xAPIKey, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *        Validates a device token for a specific platform.       Checks token format and verifies with the respective push service.       Rate limited to 10 requests per minute due to external API calls.     
         * @summary Validate device token
         * @param {string} xAPIKey API Key for authentication
         * @param {any} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesValidateToken(xAPIKey: string, projectId: any, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.devicesValidateToken(xAPIKey, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {any} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesValidateTokensBatch(xAPIKey: string, projectId: any, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesValidateTokensBatch(xAPIKey, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 */
export class DevicesApi extends BaseAPI {
    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesAddTags(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesAddTags(xAPIKey, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {string} topic 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesAddToTopic(xAPIKey: string, projectId: string, id: string, topic: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesAddToTopic(xAPIKey, projectId, id, topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} dryRun 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesCleanupTokens(xAPIKey: string, projectId: string, dryRun: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesCleanupTokens(xAPIKey, projectId, dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesCountDevicesBySegment(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesCountDevicesBySegment(xAPIKey, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} platform 
     * @param {string} userId 
     * @param {string} tags 
     * @param {string} topics 
     * @param {string} isActive 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesFindAll(xAPIKey: string, projectId: string, platform: string, userId: string, tags: string, topics: string, isActive: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesFindAll(xAPIKey, projectId, platform, userId, tags, topics, isActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesFindOne(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesFindOne(xAPIKey, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesGetProjectTags(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesGetProjectTags(xAPIKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesGetPropertyStats(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesGetPropertyStats(xAPIKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesGetStats(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesGetStats(xAPIKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesGetTagStats(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesGetTagStats(xAPIKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesGetTokensBySegment(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesGetTokensBySegment(xAPIKey, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesQueryDevicesBySegment(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesQueryDevicesBySegment(xAPIKey, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesRefreshToken(xAPIKey: string, projectId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesRefreshToken(xAPIKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Registers a new device for push notifications with enhanced validation.       Automatically detects platform and validates device tokens.       Rate limited to 100 requests per minute.     
     * @summary Register device
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {any} body Device registration payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesRegister(xAPIKey: string, projectId: string, body: any, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesRegister(xAPIKey, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesRegisterBasic(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesRegisterBasic(xAPIKey, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesRemove(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesRemove(xAPIKey, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {string} topic 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesRemoveFromTopic(xAPIKey: string, projectId: string, id: string, topic: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesRemoveFromTopic(xAPIKey, projectId, id, topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesRemoveProperties(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesRemoveProperties(xAPIKey, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesRemoveTags(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesRemoveTags(xAPIKey, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesSetProperties(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesSetProperties(xAPIKey, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesTestSegmentQuery(xAPIKey: string, projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesTestSegmentQuery(xAPIKey, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesUpdate(xAPIKey: string, projectId: string, id: string, body: object, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesUpdate(xAPIKey, projectId, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesUpdateProperties(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesUpdateProperties(xAPIKey, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesUpdateToken(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesUpdateToken(xAPIKey, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Validates a device token for a specific platform.       Checks token format and verifies with the respective push service.       Rate limited to 10 requests per minute due to external API calls.     
     * @summary Validate device token
     * @param {string} xAPIKey API Key for authentication
     * @param {any} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesValidateToken(xAPIKey: string, projectId: any, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesValidateToken(xAPIKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {any} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesValidateTokensBatch(xAPIKey: string, projectId: any, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesValidateTokensBatch(xAPIKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the health status of the Push Notification Service API.
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGetHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple ping endpoint for basic connectivity testing.
         * @summary Ping endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthPing: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/health/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the health status of the Push Notification Service API.
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGetHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGetHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthGetHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple ping endpoint for basic connectivity testing.
         * @summary Ping endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthPing(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthPing(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthPing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Returns the health status of the Push Notification Service API.
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGetHealth(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthGetHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Simple ping endpoint for basic connectivity testing.
         * @summary Ping endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthPing(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthPing(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * Returns the health status of the Push Notification Service API.
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthGetHealth(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthGetHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple ping endpoint for basic connectivity testing.
     * @summary Ping endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthPing(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthPing(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a scheduled/recurring notification
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsCancel: async (xAPIKey: string, projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('notificationsCancel', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('notificationsCancel', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsCancel', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/notifications/{id}/cancel`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get notification by id
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetById: async (xAPIKey: string, projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('notificationsGetById', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('notificationsGetById', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsGetById', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/notifications/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId 
         * @param {string} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetStats: async (xAPIKey: string, projectId: string, days: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('notificationsGetStats', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('notificationsGetStats', 'projectId', projectId)
            // verify required parameter 'days' is not null or undefined
            assertParamExists('notificationsGetStats', 'days', days)
            const localVarPath = `/api/v1/projects/{projectId}/notifications/stats`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of notifications with optional filtering by status and type.
         * @summary List notifications
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {NotificationsListStatusEnum} [status] Filter by notification status
         * @param {NotificationsListTypeEnum} [type] Filter by notification type
         * @param {number} [limit] Number of notifications to return (max 100)
         * @param {number} [offset] Number of notifications to skip (offset)
         * @param {string} [sortBy] 
         * @param {NotificationsListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsList: async (xAPIKey: string, projectId: string, status?: NotificationsListStatusEnum, type?: NotificationsListTypeEnum, limit?: number, offset?: number, sortBy?: string, sortOrder?: NotificationsListSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('notificationsList', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('notificationsList', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/notifications`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Sends a push notification to specified devices or user segments.       Supports multi-platform delivery (iOS, Android, Web) with platform-specific customization.       Rate limited to 100 requests per minute.     
         * @summary Send push notification
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} idempotencyKey 
         * @param {string} body Send payload (examples for instant and scheduled)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsSend: async (xAPIKey: string, projectId: string, idempotencyKey: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('notificationsSend', 'xAPIKey', xAPIKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('notificationsSend', 'projectId', projectId)
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('notificationsSend', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notificationsSend', 'body', body)
            const localVarPath = `/api/v1/projects/{projectId}/notifications/send`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 */
export const NotificationsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel a scheduled/recurring notification
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsCancel(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsCancel(xAPIKey, projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get notification by id
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsGetById(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsGetById(xAPIKey, projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId 
         * @param {string} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsGetStats(xAPIKey: string, projectId: string, days: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsGetStats(xAPIKey, projectId, days, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsGetStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of notifications with optional filtering by status and type.
         * @summary List notifications
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {NotificationsListStatusEnum} [status] Filter by notification status
         * @param {NotificationsListTypeEnum} [type] Filter by notification type
         * @param {number} [limit] Number of notifications to return (max 100)
         * @param {number} [offset] Number of notifications to skip (offset)
         * @param {string} [sortBy] 
         * @param {NotificationsListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsList(xAPIKey: string, projectId: string, status?: NotificationsListStatusEnum, type?: NotificationsListTypeEnum, limit?: number, offset?: number, sortBy?: string, sortOrder?: NotificationsListSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsList(xAPIKey, projectId, status, type, limit, offset, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *        Sends a push notification to specified devices or user segments.       Supports multi-platform delivery (iOS, Android, Web) with platform-specific customization.       Rate limited to 100 requests per minute.     
         * @summary Send push notification
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} idempotencyKey 
         * @param {string} body Send payload (examples for instant and scheduled)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsSend(xAPIKey: string, projectId: string, idempotencyKey: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsSend(xAPIKey, projectId, idempotencyKey, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsSend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel a scheduled/recurring notification
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsCancel(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.notificationsCancel(xAPIKey, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get notification by id
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetById(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.notificationsGetById(xAPIKey, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId 
         * @param {string} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetStats(xAPIKey: string, projectId: string, days: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.notificationsGetStats(xAPIKey, projectId, days, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of notifications with optional filtering by status and type.
         * @summary List notifications
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {NotificationsListStatusEnum} [status] Filter by notification status
         * @param {NotificationsListTypeEnum} [type] Filter by notification type
         * @param {number} [limit] Number of notifications to return (max 100)
         * @param {number} [offset] Number of notifications to skip (offset)
         * @param {string} [sortBy] 
         * @param {NotificationsListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsList(xAPIKey: string, projectId: string, status?: NotificationsListStatusEnum, type?: NotificationsListTypeEnum, limit?: number, offset?: number, sortBy?: string, sortOrder?: NotificationsListSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsList200Response> {
            return localVarFp.notificationsList(xAPIKey, projectId, status, type, limit, offset, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         *        Sends a push notification to specified devices or user segments.       Supports multi-platform delivery (iOS, Android, Web) with platform-specific customization.       Rate limited to 100 requests per minute.     
         * @summary Send push notification
         * @param {string} xAPIKey API Key for authentication
         * @param {string} projectId Project ID
         * @param {string} idempotencyKey 
         * @param {string} body Send payload (examples for instant and scheduled)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsSend(xAPIKey: string, projectId: string, idempotencyKey: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.notificationsSend(xAPIKey, projectId, idempotencyKey, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @summary Cancel a scheduled/recurring notification
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsCancel(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsCancel(xAPIKey, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get notification by id
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsGetById(xAPIKey: string, projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsGetById(xAPIKey, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId 
     * @param {string} days 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsGetStats(xAPIKey: string, projectId: string, days: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsGetStats(xAPIKey, projectId, days, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of notifications with optional filtering by status and type.
     * @summary List notifications
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {NotificationsListStatusEnum} [status] Filter by notification status
     * @param {NotificationsListTypeEnum} [type] Filter by notification type
     * @param {number} [limit] Number of notifications to return (max 100)
     * @param {number} [offset] Number of notifications to skip (offset)
     * @param {string} [sortBy] 
     * @param {NotificationsListSortOrderEnum} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsList(xAPIKey: string, projectId: string, status?: NotificationsListStatusEnum, type?: NotificationsListTypeEnum, limit?: number, offset?: number, sortBy?: string, sortOrder?: NotificationsListSortOrderEnum, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsList(xAPIKey, projectId, status, type, limit, offset, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Sends a push notification to specified devices or user segments.       Supports multi-platform delivery (iOS, Android, Web) with platform-specific customization.       Rate limited to 100 requests per minute.     
     * @summary Send push notification
     * @param {string} xAPIKey API Key for authentication
     * @param {string} projectId Project ID
     * @param {string} idempotencyKey 
     * @param {string} body Send payload (examples for instant and scheduled)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsSend(xAPIKey: string, projectId: string, idempotencyKey: string, body: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsSend(xAPIKey, projectId, idempotencyKey, body, options).then((request) => request(this.axios, this.basePath));
    }
}

export const NotificationsListStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Sent: 'sent',
    Delivered: 'delivered',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;
export type NotificationsListStatusEnum = typeof NotificationsListStatusEnum[keyof typeof NotificationsListStatusEnum];
export const NotificationsListTypeEnum = {
    Instant: 'instant',
    Scheduled: 'scheduled',
    Recurring: 'recurring'
} as const;
export type NotificationsListTypeEnum = typeof NotificationsListTypeEnum[keyof typeof NotificationsListTypeEnum];
export const NotificationsListSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type NotificationsListSortOrderEnum = typeof NotificationsListSortOrderEnum[keyof typeof NotificationsListSortOrderEnum];


/**
 * ProjectsApi - axios parameter creator
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new push notification project with auto-generated API key and configuration.
         * @summary Create a new project
         * @param {string} xAPIKey API Key for authentication
         * @param {any} body Project payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate: async (xAPIKey: string, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('projectsCreate', 'xAPIKey', xAPIKey)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectsCreate', 'body', body)
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific project by ID. Users can only access their own project.
         * @summary Get project by ID
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsFindOne: async (xAPIKey: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('projectsFindOne', 'xAPIKey', xAPIKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsFindOne', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the project associated with the provided API key.
         * @summary Get authenticated project
         * @param {string} xAPIKey API Key for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetCurrent: async (xAPIKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('projectsGetCurrent', 'xAPIKey', xAPIKey)
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a project and all associated data. This action cannot be undone.
         * @summary Delete project
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsRemove: async (xAPIKey: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('projectsRemove', 'xAPIKey', xAPIKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsRemove', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a new API key for the project. The old API key will become invalid immediately.
         * @summary Regenerate API key
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsRotateApiKey: async (xAPIKey: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('projectsRotateApiKey', 'xAPIKey', xAPIKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsRotateApiKey', 'id', id)
            const localVarPath = `/api/v1/projects/{id}/regenerate-api-key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates project settings and configuration. Users can only update their own project.
         * @summary Update project
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID to update
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate: async (xAPIKey: string, id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAPIKey' is not null or undefined
            assertParamExists('projectsUpdate', 'xAPIKey', xAPIKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectsUpdate', 'body', body)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 */
export const ProjectsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new push notification project with auto-generated API key and configuration.
         * @summary Create a new project
         * @param {string} xAPIKey API Key for authentication
         * @param {any} body Project payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsCreate(xAPIKey: string, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsCreate(xAPIKey, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific project by ID. Users can only access their own project.
         * @summary Get project by ID
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsFindOne(xAPIKey: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsFindOne(xAPIKey, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the project associated with the provided API key.
         * @summary Get authenticated project
         * @param {string} xAPIKey API Key for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetCurrent(xAPIKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGetCurrent(xAPIKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsGetCurrent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a project and all associated data. This action cannot be undone.
         * @summary Delete project
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsRemove(xAPIKey: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsRemove(xAPIKey, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a new API key for the project. The old API key will become invalid immediately.
         * @summary Regenerate API key
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsRotateApiKey(xAPIKey: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsRotateApiKey(xAPIKey, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsRotateApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates project settings and configuration. Users can only update their own project.
         * @summary Update project
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID to update
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsUpdate(xAPIKey: string, id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsUpdate(xAPIKey, id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Creates a new push notification project with auto-generated API key and configuration.
         * @summary Create a new project
         * @param {string} xAPIKey API Key for authentication
         * @param {any} body Project payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate(xAPIKey: string, body: any, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.projectsCreate(xAPIKey, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific project by ID. Users can only access their own project.
         * @summary Get project by ID
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsFindOne(xAPIKey: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsFindOne(xAPIKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the project associated with the provided API key.
         * @summary Get authenticated project
         * @param {string} xAPIKey API Key for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetCurrent(xAPIKey: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.projectsGetCurrent(xAPIKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a project and all associated data. This action cannot be undone.
         * @summary Delete project
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsRemove(xAPIKey: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsRemove(xAPIKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a new API key for the project. The old API key will become invalid immediately.
         * @summary Regenerate API key
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsRotateApiKey(xAPIKey: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.projectsRotateApiKey(xAPIKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates project settings and configuration. Users can only update their own project.
         * @summary Update project
         * @param {string} xAPIKey API Key for authentication
         * @param {string} id Project ID to update
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate(xAPIKey: string, id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsUpdate(xAPIKey, id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Creates a new push notification project with auto-generated API key and configuration.
     * @summary Create a new project
     * @param {string} xAPIKey API Key for authentication
     * @param {any} body Project payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsCreate(xAPIKey: string, body: any, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsCreate(xAPIKey, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific project by ID. Users can only access their own project.
     * @summary Get project by ID
     * @param {string} xAPIKey API Key for authentication
     * @param {string} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsFindOne(xAPIKey: string, id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsFindOne(xAPIKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the project associated with the provided API key.
     * @summary Get authenticated project
     * @param {string} xAPIKey API Key for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsGetCurrent(xAPIKey: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsGetCurrent(xAPIKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a project and all associated data. This action cannot be undone.
     * @summary Delete project
     * @param {string} xAPIKey API Key for authentication
     * @param {string} id Project ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsRemove(xAPIKey: string, id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsRemove(xAPIKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a new API key for the project. The old API key will become invalid immediately.
     * @summary Regenerate API key
     * @param {string} xAPIKey API Key for authentication
     * @param {string} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsRotateApiKey(xAPIKey: string, id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsRotateApiKey(xAPIKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates project settings and configuration. Users can only update their own project.
     * @summary Update project
     * @param {string} xAPIKey API Key for authentication
     * @param {string} id Project ID to update
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsUpdate(xAPIKey: string, id: string, body: object, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsUpdate(xAPIKey, id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QueuesApi - axios parameter creator
 */
export const QueuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesAddJob: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queuesAddJob', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/queues/jobs`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesCancelJob: async (projectId: string, queueName: string, jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queuesCancelJob', 'projectId', projectId)
            // verify required parameter 'queueName' is not null or undefined
            assertParamExists('queuesCancelJob', 'queueName', queueName)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('queuesCancelJob', 'jobId', jobId)
            const localVarPath = `/api/v1/projects/{projectId}/queues/jobs/{queueName}/{jobId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"queueName"}}`, encodeURIComponent(String(queueName)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesGetHealthStatus: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queuesGetHealthStatus', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/queues/health`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesGetJobStatus: async (projectId: string, queueName: string, jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queuesGetJobStatus', 'projectId', projectId)
            // verify required parameter 'queueName' is not null or undefined
            assertParamExists('queuesGetJobStatus', 'queueName', queueName)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('queuesGetJobStatus', 'jobId', jobId)
            const localVarPath = `/api/v1/projects/{projectId}/queues/jobs/{queueName}/{jobId}/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"queueName"}}`, encodeURIComponent(String(queueName)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesGetQueueStats: async (projectId: string, queue: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queuesGetQueueStats', 'projectId', projectId)
            // verify required parameter 'queue' is not null or undefined
            assertParamExists('queuesGetQueueStats', 'queue', queue)
            const localVarPath = `/api/v1/projects/{projectId}/queues/stats`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (queue !== undefined) {
                localVarQueryParameter['queue'] = queue;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesPauseQueue: async (projectId: string, queueName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queuesPauseQueue', 'projectId', projectId)
            // verify required parameter 'queueName' is not null or undefined
            assertParamExists('queuesPauseQueue', 'queueName', queueName)
            const localVarPath = `/api/v1/projects/{projectId}/queues/{queueName}/pause`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"queueName"}}`, encodeURIComponent(String(queueName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesResumeQueue: async (projectId: string, queueName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queuesResumeQueue', 'projectId', projectId)
            // verify required parameter 'queueName' is not null or undefined
            assertParamExists('queuesResumeQueue', 'queueName', queueName)
            const localVarPath = `/api/v1/projects/{projectId}/queues/{queueName}/resume`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"queueName"}}`, encodeURIComponent(String(queueName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueuesApi - functional programming interface
 */
export const QueuesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = QueuesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queuesAddJob(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queuesAddJob(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.queuesAddJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queuesCancelJob(projectId: string, queueName: string, jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queuesCancelJob(projectId, queueName, jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.queuesCancelJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queuesGetHealthStatus(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queuesGetHealthStatus(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.queuesGetHealthStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queuesGetJobStatus(projectId: string, queueName: string, jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queuesGetJobStatus(projectId, queueName, jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.queuesGetJobStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queuesGetQueueStats(projectId: string, queue: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queuesGetQueueStats(projectId, queue, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.queuesGetQueueStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queuesPauseQueue(projectId: string, queueName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queuesPauseQueue(projectId, queueName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.queuesPauseQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queuesResumeQueue(projectId: string, queueName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queuesResumeQueue(projectId, queueName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.queuesResumeQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueuesApi - factory interface
 */
export const QueuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueuesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesAddJob(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.queuesAddJob(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesCancelJob(projectId: string, queueName: string, jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.queuesCancelJob(projectId, queueName, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesGetHealthStatus(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.queuesGetHealthStatus(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesGetJobStatus(projectId: string, queueName: string, jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.queuesGetJobStatus(projectId, queueName, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesGetQueueStats(projectId: string, queue: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.queuesGetQueueStats(projectId, queue, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesPauseQueue(projectId: string, queueName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.queuesPauseQueue(projectId, queueName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} queueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesResumeQueue(projectId: string, queueName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.queuesResumeQueue(projectId, queueName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueuesApi - object-oriented interface
 */
export class QueuesApi extends BaseAPI {
    /**
     * 
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queuesAddJob(projectId: string, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).queuesAddJob(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} queueName 
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queuesCancelJob(projectId: string, queueName: string, jobId: string, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).queuesCancelJob(projectId, queueName, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queuesGetHealthStatus(projectId: string, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).queuesGetHealthStatus(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} queueName 
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queuesGetJobStatus(projectId: string, queueName: string, jobId: string, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).queuesGetJobStatus(projectId, queueName, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} queue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queuesGetQueueStats(projectId: string, queue: string, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).queuesGetQueueStats(projectId, queue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} queueName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queuesPauseQueue(projectId: string, queueName: string, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).queuesPauseQueue(projectId, queueName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} queueName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queuesResumeQueue(projectId: string, queueName: string, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).queuesResumeQueue(projectId, queueName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RateLimitAdminApi - axios parameter creator
 */
export const RateLimitAdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current project rate limit status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateLimitAdminGetCurrentProjectRateLimitStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admin/rate-limits/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get rate limit status for a project
         * @param {string} projectId Project ID to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateLimitAdminGetProjectRateLimitStatus: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rateLimitAdminGetProjectRateLimitStatus', 'projectId', projectId)
            const localVarPath = `/api/v1/admin/rate-limits/status/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check rate limiting system health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateLimitAdminGetRateLimitHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admin/rate-limits/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset rate limits for current project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateLimitAdminResetCurrentProjectRateLimits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admin/rate-limits/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset rate limits for a project
         * @param {string} projectId Project ID to reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateLimitAdminResetProjectRateLimits: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rateLimitAdminResetProjectRateLimits', 'projectId', projectId)
            const localVarPath = `/api/v1/admin/rate-limits/reset/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RateLimitAdminApi - functional programming interface
 */
export const RateLimitAdminApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RateLimitAdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current project rate limit status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rateLimitAdminGetCurrentProjectRateLimitStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rateLimitAdminGetCurrentProjectRateLimitStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RateLimitAdminApi.rateLimitAdminGetCurrentProjectRateLimitStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get rate limit status for a project
         * @param {string} projectId Project ID to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rateLimitAdminGetProjectRateLimitStatus(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rateLimitAdminGetProjectRateLimitStatus(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RateLimitAdminApi.rateLimitAdminGetProjectRateLimitStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check rate limiting system health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rateLimitAdminGetRateLimitHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rateLimitAdminGetRateLimitHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RateLimitAdminApi.rateLimitAdminGetRateLimitHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset rate limits for current project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rateLimitAdminResetCurrentProjectRateLimits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rateLimitAdminResetCurrentProjectRateLimits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RateLimitAdminApi.rateLimitAdminResetCurrentProjectRateLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset rate limits for a project
         * @param {string} projectId Project ID to reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rateLimitAdminResetProjectRateLimits(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rateLimitAdminResetProjectRateLimits(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RateLimitAdminApi.rateLimitAdminResetProjectRateLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RateLimitAdminApi - factory interface
 */
export const RateLimitAdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RateLimitAdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current project rate limit status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateLimitAdminGetCurrentProjectRateLimitStatus(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rateLimitAdminGetCurrentProjectRateLimitStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get rate limit status for a project
         * @param {string} projectId Project ID to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateLimitAdminGetProjectRateLimitStatus(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rateLimitAdminGetProjectRateLimitStatus(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check rate limiting system health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateLimitAdminGetRateLimitHealth(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rateLimitAdminGetRateLimitHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset rate limits for current project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateLimitAdminResetCurrentProjectRateLimits(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rateLimitAdminResetCurrentProjectRateLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset rate limits for a project
         * @param {string} projectId Project ID to reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateLimitAdminResetProjectRateLimits(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rateLimitAdminResetProjectRateLimits(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RateLimitAdminApi - object-oriented interface
 */
export class RateLimitAdminApi extends BaseAPI {
    /**
     * 
     * @summary Get current project rate limit status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rateLimitAdminGetCurrentProjectRateLimitStatus(options?: RawAxiosRequestConfig) {
        return RateLimitAdminApiFp(this.configuration).rateLimitAdminGetCurrentProjectRateLimitStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get rate limit status for a project
     * @param {string} projectId Project ID to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rateLimitAdminGetProjectRateLimitStatus(projectId: string, options?: RawAxiosRequestConfig) {
        return RateLimitAdminApiFp(this.configuration).rateLimitAdminGetProjectRateLimitStatus(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check rate limiting system health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rateLimitAdminGetRateLimitHealth(options?: RawAxiosRequestConfig) {
        return RateLimitAdminApiFp(this.configuration).rateLimitAdminGetRateLimitHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset rate limits for current project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rateLimitAdminResetCurrentProjectRateLimits(options?: RawAxiosRequestConfig) {
        return RateLimitAdminApiFp(this.configuration).rateLimitAdminResetCurrentProjectRateLimits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset rate limits for a project
     * @param {string} projectId Project ID to reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rateLimitAdminResetProjectRateLimits(projectId: string, options?: RawAxiosRequestConfig) {
        return RateLimitAdminApiFp(this.configuration).rateLimitAdminResetProjectRateLimits(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new notification template
         * @param {string} projectId Project ID
         * @param {CreateTemplateDto} createTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesCreate: async (projectId: string, createTemplateDto: CreateTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('templatesCreate', 'projectId', projectId)
            // verify required parameter 'createTemplateDto' is not null or undefined
            assertParamExists('templatesCreate', 'createTemplateDto', createTemplateDto)
            const localVarPath = `/api/v1/projects/{projectId}/templates`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all templates for a project
         * @param {string} projectId Project ID
         * @param {TemplatesFindAllStatusEnum} [status] 
         * @param {string} [language] Filter by language
         * @param {number} [limit] Limit number of results
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesFindAll: async (projectId: string, status?: TemplatesFindAllStatusEnum, language?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('templatesFindAll', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/templates`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific template by name
         * @param {string} projectId Project ID
         * @param {string} name Template name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesFindByName: async (projectId: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('templatesFindByName', 'projectId', projectId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('templatesFindByName', 'name', name)
            const localVarPath = `/api/v1/projects/{projectId}/templates/name/{name}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific template by ID
         * @param {string} projectId Project ID
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesFindOne: async (projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('templatesFindOne', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templatesFindOne', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/templates/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get template usage statistics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesGetStatistics: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('templatesGetStatistics', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/templates/statistics`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a template
         * @param {string} projectId Project ID
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesRemove: async (projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('templatesRemove', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templatesRemove', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/templates/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Render a template with variables
         * @param {string} projectId Project ID
         * @param {RenderTemplateDto} renderTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesRender: async (projectId: string, renderTemplateDto: RenderTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('templatesRender', 'projectId', projectId)
            // verify required parameter 'renderTemplateDto' is not null or undefined
            assertParamExists('templatesRender', 'renderTemplateDto', renderTemplateDto)
            const localVarPath = `/api/v1/projects/{projectId}/templates/render`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(renderTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a template
         * @param {string} projectId Project ID
         * @param {string} id Template ID
         * @param {UpdateTemplateDto} updateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesUpdate: async (projectId: string, id: string, updateTemplateDto: UpdateTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('templatesUpdate', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templatesUpdate', 'id', id)
            // verify required parameter 'updateTemplateDto' is not null or undefined
            assertParamExists('templatesUpdate', 'updateTemplateDto', updateTemplateDto)
            const localVarPath = `/api/v1/projects/{projectId}/templates/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate template syntax and variables
         * @param {string} projectId Project ID
         * @param {ValidateTemplateDto} validateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesValidate: async (projectId: string, validateTemplateDto: ValidateTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('templatesValidate', 'projectId', projectId)
            // verify required parameter 'validateTemplateDto' is not null or undefined
            assertParamExists('templatesValidate', 'validateTemplateDto', validateTemplateDto)
            const localVarPath = `/api/v1/projects/{projectId}/templates/validate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(validateTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 */
export const TemplatesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new notification template
         * @param {string} projectId Project ID
         * @param {CreateTemplateDto} createTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesCreate(projectId: string, createTemplateDto: CreateTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesCreate(projectId, createTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all templates for a project
         * @param {string} projectId Project ID
         * @param {TemplatesFindAllStatusEnum} [status] 
         * @param {string} [language] Filter by language
         * @param {number} [limit] Limit number of results
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesFindAll(projectId: string, status?: TemplatesFindAllStatusEnum, language?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesFindAll(projectId, status, language, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific template by name
         * @param {string} projectId Project ID
         * @param {string} name Template name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesFindByName(projectId: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesFindByName(projectId, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesFindByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific template by ID
         * @param {string} projectId Project ID
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesFindOne(projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesFindOne(projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get template usage statistics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesGetStatistics(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesGetStatistics(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesGetStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a template
         * @param {string} projectId Project ID
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesRemove(projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesRemove(projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Render a template with variables
         * @param {string} projectId Project ID
         * @param {RenderTemplateDto} renderTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesRender(projectId: string, renderTemplateDto: RenderTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesRender(projectId, renderTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesRender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a template
         * @param {string} projectId Project ID
         * @param {string} id Template ID
         * @param {UpdateTemplateDto} updateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesUpdate(projectId: string, id: string, updateTemplateDto: UpdateTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesUpdate(projectId, id, updateTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate template syntax and variables
         * @param {string} projectId Project ID
         * @param {ValidateTemplateDto} validateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesValidate(projectId: string, validateTemplateDto: ValidateTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesValidate(projectId, validateTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new notification template
         * @param {string} projectId Project ID
         * @param {CreateTemplateDto} createTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesCreate(projectId: string, createTemplateDto: CreateTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesCreate(projectId, createTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all templates for a project
         * @param {string} projectId Project ID
         * @param {TemplatesFindAllStatusEnum} [status] 
         * @param {string} [language] Filter by language
         * @param {number} [limit] Limit number of results
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesFindAll(projectId: string, status?: TemplatesFindAllStatusEnum, language?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesFindAll(projectId, status, language, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific template by name
         * @param {string} projectId Project ID
         * @param {string} name Template name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesFindByName(projectId: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesFindByName(projectId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific template by ID
         * @param {string} projectId Project ID
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesFindOne(projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesFindOne(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get template usage statistics
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesGetStatistics(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesGetStatistics(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a template
         * @param {string} projectId Project ID
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesRemove(projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesRemove(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Render a template with variables
         * @param {string} projectId Project ID
         * @param {RenderTemplateDto} renderTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesRender(projectId: string, renderTemplateDto: RenderTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesRender(projectId, renderTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a template
         * @param {string} projectId Project ID
         * @param {string} id Template ID
         * @param {UpdateTemplateDto} updateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesUpdate(projectId: string, id: string, updateTemplateDto: UpdateTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesUpdate(projectId, id, updateTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate template syntax and variables
         * @param {string} projectId Project ID
         * @param {ValidateTemplateDto} validateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesValidate(projectId: string, validateTemplateDto: ValidateTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesValidate(projectId, validateTemplateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new notification template
     * @param {string} projectId Project ID
     * @param {CreateTemplateDto} createTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public templatesCreate(projectId: string, createTemplateDto: CreateTemplateDto, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesCreate(projectId, createTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all templates for a project
     * @param {string} projectId Project ID
     * @param {TemplatesFindAllStatusEnum} [status] 
     * @param {string} [language] Filter by language
     * @param {number} [limit] Limit number of results
     * @param {number} [offset] Offset for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public templatesFindAll(projectId: string, status?: TemplatesFindAllStatusEnum, language?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesFindAll(projectId, status, language, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific template by name
     * @param {string} projectId Project ID
     * @param {string} name Template name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public templatesFindByName(projectId: string, name: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesFindByName(projectId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific template by ID
     * @param {string} projectId Project ID
     * @param {string} id Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public templatesFindOne(projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesFindOne(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get template usage statistics
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public templatesGetStatistics(projectId: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesGetStatistics(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a template
     * @param {string} projectId Project ID
     * @param {string} id Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public templatesRemove(projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesRemove(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Render a template with variables
     * @param {string} projectId Project ID
     * @param {RenderTemplateDto} renderTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public templatesRender(projectId: string, renderTemplateDto: RenderTemplateDto, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesRender(projectId, renderTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a template
     * @param {string} projectId Project ID
     * @param {string} id Template ID
     * @param {UpdateTemplateDto} updateTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public templatesUpdate(projectId: string, id: string, updateTemplateDto: UpdateTemplateDto, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesUpdate(projectId, id, updateTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate template syntax and variables
     * @param {string} projectId Project ID
     * @param {ValidateTemplateDto} validateTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public templatesValidate(projectId: string, validateTemplateDto: ValidateTemplateDto, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesValidate(projectId, validateTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const TemplatesFindAllStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;
export type TemplatesFindAllStatusEnum = typeof TemplatesFindAllStatusEnum[keyof typeof TemplatesFindAllStatusEnum];


/**
 * WebhooksApi - axios parameter creator
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a project webhook
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksAdd: async (projectId: string, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhooksAdd', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/webhooks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project webhooks
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksList: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhooksList', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/webhooks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List webhook delivery logs (paginated)
         * @param {string} projectId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksListDeliveries: async (projectId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhooksListDeliveries', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/webhooks/deliveries`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a webhook by index
         * @param {string} projectId 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksRemove: async (projectId: string, index: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhooksRemove', 'projectId', projectId)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('webhooksRemove', 'index', index)
            const localVarPath = `/api/v1/projects/{projectId}/webhooks/{index}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rotate webhook signing secret
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksRotateSecret: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhooksRotateSecret', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/webhooks/secret/rotate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a webhook by index
         * @param {string} projectId 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksUpdate: async (projectId: string, index: string, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhooksUpdate', 'projectId', projectId)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('webhooksUpdate', 'index', index)
            const localVarPath = `/api/v1/projects/{projectId}/webhooks/{index}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a project webhook
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksAdd(projectId: string, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksAdd(projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksAdd']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List project webhooks
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksList(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksList(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List webhook delivery logs (paginated)
         * @param {string} projectId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksListDeliveries(projectId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksListDeliveries(projectId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksListDeliveries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a webhook by index
         * @param {string} projectId 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksRemove(projectId: string, index: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksRemove(projectId, index, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Rotate webhook signing secret
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksRotateSecret(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksRotateSecret(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksRotateSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a webhook by index
         * @param {string} projectId 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksUpdate(projectId: string, index: string, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksUpdate(projectId, index, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a project webhook
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksAdd(projectId: string, body: any, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webhooksAdd(projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project webhooks
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksList(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webhooksList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List webhook delivery logs (paginated)
         * @param {string} projectId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksListDeliveries(projectId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webhooksListDeliveries(projectId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a webhook by index
         * @param {string} projectId 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksRemove(projectId: string, index: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webhooksRemove(projectId, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rotate webhook signing secret
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksRotateSecret(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webhooksRotateSecret(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a webhook by index
         * @param {string} projectId 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksUpdate(projectId: string, index: string, body: any, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webhooksUpdate(projectId, index, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 */
export class WebhooksApi extends BaseAPI {
    /**
     * 
     * @summary Add a project webhook
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksAdd(projectId: string, body: any, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksAdd(projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project webhooks
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksList(projectId: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List webhook delivery logs (paginated)
     * @param {string} projectId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksListDeliveries(projectId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksListDeliveries(projectId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a webhook by index
     * @param {string} projectId 
     * @param {string} index 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksRemove(projectId: string, index: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksRemove(projectId, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rotate webhook signing secret
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksRotateSecret(projectId: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksRotateSecret(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a webhook by index
     * @param {string} projectId 
     * @param {string} index 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksUpdate(projectId: string, index: string, body: any, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksUpdate(projectId, index, body, options).then((request) => request(this.axios, this.basePath));
    }
}



